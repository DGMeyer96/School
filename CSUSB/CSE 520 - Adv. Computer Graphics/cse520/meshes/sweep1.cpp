
/*  sweep1.cpp
 *  Construct surfaces of revolution but have not considered lighting and wireframe is used.
 *  Surface is generated by revolving a curve around x-axis.			
 *  A curve f(x) is generated by polynomial interpretation from some control points
 *  or by some interested functions.
 *
 *  @Author: T.L. Yu, Fall 2008 
 */
#include <GL/glut.h>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <stdlib.h>

using namespace std;

const double PI = 3.14159265389;

int anglex= 0, angley = 0, anglez = 0;          //rotation angles
int window;

//control points
GLfloat ctrlpoints[4][3] = {
	{ 0.0, 0.0, 0.0}, { 1.0, 0.5, 0.0}, 
	{2.0, 1.2, 0.0}, {3.0, 3, 0.0}};


void init(void)
{
   glClearColor(1.0, 1.0, 1.0, 1.0);
   glPolygonMode( GL_FRONT, GL_LINE ) ;
   glPolygonMode( GL_BACK,  GL_LINE ) ;
//   glPolygonMode( GL_FRONT, GL_FILL ) ;

   glEnable( GL_CULL_FACE );
   glCullFace ( GL_BACK );
//   glPolygonMode( GL_FRONT, GL_FILL );
 /*  glShadeModel(GL_FLAT);
  */
}


//polynomial interpolation for N points
float polyint ( float  points[][3], float x, int N )
{
  float y;

  float num = 1.0, den = 1.0;
  float sum = 0.0;

  for ( int i = 0; i < N; ++i ) {
    num = den = 1.0;
    for ( int j = 0; j < N; ++j ) {
      if ( j == i ) continue;

      num = num * ( x - points[j][0] );		 	//x - xj
    }
    for ( int j = 0; j < N; ++j ) {
      if ( j == i ) continue;
      den = den * ( points[i][0] - points[j][0] );	//xi - xj
    }
    sum += num / den * points[i][1];
  }
  y = sum;

  return y;
}

float aLine ( float x )
{
  return x + 2.5;
}

void bspline ( float  points[][3], float t, float out[] )
{
  // the t value inverted
  float it = 1.0f-t;

  // calculate blending functions
  float b0 = it*it*it;
  float b1 = 3*t*it*it;
  float b2 = 3*t*t*it;
  float b3 = t*t*t;

  // sum the control points mulitplied by their respective blending functions
  out[0] = b0*points[0][0] + b1*points[1][0] + b2*points[2][0] + b3*points[3][0];       //x
  out[1] = b0*points[0][1] + b1*points[1][1] + b2*points[2][1] + b3*points[3][1];       //y
  out[2] = b0*points[0][2] + b1*points[1][2] + b2*points[2][2] + b3*points[3][2];       //z
}

void display(void)
{
   int i, j;
   float x, y, z, r;				//current coordinates
   float x1, y1, z1, r1;			//next coordinates
   float theta;

   glClear(GL_COLOR_BUFFER_BIT);
   glColor3f(0.0, 1.0, 1.0);
   const float startx = 0, endx = 3;
   const int nx = 32;				//number of slices along x-direction
   const int ntheta = 32;			//number of angular slices
   const float dx = (endx - startx) / nx;	//x step size
   const float dtheta = 2*PI / ntheta;		//angular step size

   x = startx;
   //r = aLine ( x );
   r = polyint( ctrlpoints, x, 4);
   glPushMatrix();
   glRotatef( anglex, 1.0, 0.0, 0.0);       	//rotate the object about x-axis
   glRotatef( angley, 0.0, 1.0, 0.0);         	//rotate about y-axis   
   glRotatef( anglez, 0.0, 0.0, 1.0);		//rotate about z-axis
  
   for ( i = 1; i <= nx; ++i ) {		//step through x
      theta = 0;
      x1 = x + dx;				//next x
      //r1 = aLine ( x1 );			//next f(x)
      r1 = polyint( ctrlpoints, x1, 4);		//next f(x)
      //draw the surface composed of quadrilaterals by sweeping theta
      glBegin( GL_QUAD_STRIP );
	for ( j = 0; j <= ntheta; ++j ) {
	  theta += dtheta;
	  double cosa = cos( theta );
	  double sina = sin ( theta );
	  y = r * cosa;  y1 = r1 * cosa;	//current and next y
	  z = r * sina;	 z1 = r1 * sina;	//current and next z
	 
	  //edge from point at x to point at next x
	  glVertex3f (x, y, z);
	  glVertex3f (x1, y1, z1);
	  
	  //forms quad with next pair of points with incremented theta value	
	}			  	
      glEnd();
      x = x1;
      r = r1;	
   } //for i

   /* The following code displays the control points as dots. */
   glPointSize(5.0);
   glColor3f(1.0, 0.0, 1.0);
   glBegin(GL_POINTS);
      for (i = 0; i < 4; i++) 
         glVertex3fv(&ctrlpoints[i][0]);
   glEnd();
   glPopMatrix();
   glFlush();
}


void reshape(int w, int h)
{
   glViewport(0, 0, (GLsizei) w, (GLsizei) h);
   glMatrixMode(GL_PROJECTION);
   glLoadIdentity();
   if (w <= h)
      glOrtho(-5.0, 5.0, -5.0*(GLfloat)h/(GLfloat)w, 
               5.0*(GLfloat)h/(GLfloat)w, -5.0, 5.0);
   else
      glOrtho(-5.0*(GLfloat)w/(GLfloat)h, 
               5.0*(GLfloat)w/(GLfloat)h, -5.0, 5.0, -5.0, 5.0);
   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity();
}


/*
void reshape(int w, int h)
{
   glViewport(0, 0, (GLsizei) w, (GLsizei) h);
   glMatrixMode(GL_PROJECTION);
   glLoadIdentity();
   gluPerspective(60.0, (GLfloat) w/(GLfloat) h, 1.0, 30.0);
   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity();
   gluLookAt ( 0, 0, 15, 0, 0, 0, 0, 1, 0 );
}
*/

void keyboard(unsigned char key, int x, int y)
{
  switch(key) {
    case 'x':
      anglex = ( anglex + 3 ) % 360;
      break;
    case 'X':
      anglex = ( anglex - 3 ) % 360;
      break;
    case 'y':
      angley = ( angley + 3 ) % 360;
      break;
    case 'Y':
      angley = ( angley - 3 ) % 360;
      break;
    case 'z':
      anglez = ( anglez + 3 ) % 360;
      break;
    case 'Z':
      anglez = ( anglez - 3 ) % 360;
      break;
    case 'r':					//reset
      anglez = angley = anglex = 0;
      glLoadIdentity();
      break;
    case 27: /* escape */
        glutDestroyWindow(window);
        exit(0);
  }
  glutPostRedisplay();
}

int main(int argc, char** argv)
{
   glutInit(&argc, argv);
   glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);
   glutInitWindowSize (500, 500);
   glutInitWindowPosition (100, 100);
   glutCreateWindow (argv[0]);
   init ();
   glutDisplayFunc(display);
   glutReshapeFunc(reshape);
   glutKeyboardFunc (keyboard);
   glutMainLoop();
   return 0;
}
